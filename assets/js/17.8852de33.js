(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{338:function(v,_,e){"use strict";e.r(_);var i=e(3),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"_1-redis和memcache有什么区别-如何选用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis和memcache有什么区别-如何选用"}},[v._v("#")]),v._v(" 1.Redis和Memcache有什么区别？如何选用？")]),v._v(" "),e("p",[e("strong",[v._v("Redis:")])]),v._v(" "),e("ul",[e("li",[v._v("单线程模式处理请求（非阻塞异步处理机制，内存IO），避免上下文切换")]),v._v(" "),e("li",[v._v("支持多种数据格式，String，hash，list，set，sorted Set")]),v._v(" "),e("li",[v._v("主从同步机制，持久化")])]),v._v(" "),e("p",[e("strong",[v._v("Memcache:")])]),v._v(" "),e("ul",[e("li",[v._v("多线程异步IO")]),v._v(" "),e("li",[v._v("内存存储数据，支持key-value数据结构，不支持持久化，主从同步")]),v._v(" "),e("li",[v._v("可设置失效期，延迟生效")]),v._v(" "),e("li",[v._v("当容量满会对缓存中的数据进行剔除，对过期的Key进行清理，还会 通过Lru策略对数据进行剔除")]),v._v(" "),e("li",[v._v("Key不能超过250个字节，value不能超过1m字节，最大生效时间30天")])]),v._v(" "),e("p",[v._v("##2.Redis数据结构")]),v._v(" "),e("ul",[e("li",[v._v("String：SDS实现（类似java的ArrayList）")]),v._v(" "),e("li",[v._v("List：ziplist压缩列表和linkedlist双向链表，3.2版本增加qquicklist，一个双向无环链表")]),v._v(" "),e("li",[v._v("hash：ziplist和hashtable两种实现，hash表中所有的key和value长度都小于64字节，并且键值数量小于512采用压缩表来节省空间，超过采用hashtable")]),v._v(" "),e("li",[v._v("Set：内部实现可以是inset或者hashtable")]),v._v(" "),e("li",[v._v("sorted set：实现可以是ziplist或者是skiplist,元素数量小于128并且所有元素长度小于64使用ziplist，否则转为skiplist")])]),v._v(" "),e("p",[v._v("##3.Redis持久化方式")]),v._v(" "),e("ul",[e("li",[v._v("RDB：将Redis在内存数据库的记录定时dump到磁盘上")]),v._v(" "),e("li",[v._v("AOF：将Redis的操作日志以追加的方式写入到文件")])]),v._v(" "),e("p",[e("strong",[v._v("两种方式的区别")])]),v._v(" "),e("p",[v._v("RDB：\n"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FireHH/github_img_repository/redisrdb.png",alt:""}}),v._v("\nAOF：\n"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FireHH/github_img_repository/redisaof.png",alt:""}})]),v._v(" "),e("p",[v._v("##4.Redis的过期机制，Redis有哪些淘汰策略\nredis的过期策略：每隔100ms随机抽一些key检查，定期删除+惰性删除\n###定时删除\n"),e("strong",[v._v("含义：")]),v._v("\n在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除\n优点：保证内存被尽快释放")]),v._v(" "),e("p",[e("strong",[v._v("缺点：")]),v._v("\n若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key\n定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重\n没人用")]),v._v(" "),e("p",[v._v("###惰性删除\n"),e("strong",[v._v("含义：")]),v._v("\nkey过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。")]),v._v(" "),e("p",[e("strong",[v._v("优点：")]),v._v("\n删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）")]),v._v(" "),e("p",[e("strong",[v._v("缺点：")]),v._v("\n若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）")]),v._v(" "),e("p",[v._v("###定期删除\n"),e("strong",[v._v("含义：")]),v._v("\n每隔一段时间执行一次删除过期key操作")]),v._v(" "),e("p",[e("strong",[v._v("优点：")]),v._v('\n通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点\n定期删除过期key--处理"惰性删除"的缺点')]),v._v(" "),e("p",[e("strong",[v._v("缺点：")]),v._v('\n在内存友好方面，不如"定时删除"\n在CPU时间友好方面，不如"惰性删除"')]),v._v(" "),e("p",[e("strong",[v._v("难点")]),v._v("\n合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）")]),v._v(" "),e("p",[v._v("###大量过期的数据未删除，则采用内存淘汰机制\n内存淘汰机制：")]),v._v(" "),e("ul",[e("li",[v._v("no-eviction： 当内存不足时，新写入数据报错")]),v._v(" "),e("li",[v._v("allkeys-lru：  当内存不足容纳新数据时，移除最近做少使用的key（更多选用）")]),v._v(" "),e("li",[v._v("allkeys-random：当内存不足容纳新数据时，随机移除某一个key")]),v._v(" "),e("li",[v._v("volatile-lru：当内存不足容纳新数据时，设置了过期时间的key中，移除最近最少使用的key")]),v._v(" "),e("li",[v._v("volatile-random：当内存不足容纳新数据时，设置了过期时间的key中，随机移除某个key")]),v._v(" "),e("li",[v._v("volatile-ttl：当内存不足容纳新数据时，设置了过期时间的key中，有更早过期key优先移除")])]),v._v(" "),e("p",[v._v("###※ 什么时候会执行内存淘汰策略，内存占用率过高的标准是什么？")]),v._v(" "),e("p",[v._v("redis.conf配置文件中的 maxmemory 属性限定了 Redis 最大内存使用量，当占用内存大于maxmemory的配置值时会执行内存淘汰策略。")]),v._v(" "),e("p",[v._v("###※ 内存淘汰策略的配置")]),v._v(" "),e("p",[v._v("内存淘汰机制由redis.conf配置文件中的maxmemory-policy属性设置，没有配置时默认为no-eviction模式。")]),v._v(" "),e("p",[v._v("###※ 淘汰策略的执行过程")]),v._v(" "),e("ul",[e("li",[v._v("1.客户端执行一条命令，导致Redis需要增加数据（比如set key value）；")]),v._v(" "),e("li",[v._v("2.Redis会检查内存使用情况，如果内存使用超过 maxmemory，就会按照配置的置换策略maxmemory-policy删除一些key；")]),v._v(" "),e("li",[v._v("3.再执行新的数据的set操作；")])]),v._v(" "),e("p",[v._v("##5淘汰策略算法")]),v._v(" "),e("ul",[e("li",[v._v("FIFO：先进先出")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FireHH/github_img_repository/redisfifo.png",alt:""}})]),v._v(" "),e("ul",[e("li",[v._v("LRU：最近最少使用，关注数据最近访问的时间")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FireHH/github_img_repository/redislru.png",alt:""}})]),v._v(" "),e("ul",[e("li",[v._v("LFU：最近最少使用，关注数据最近访问的次数")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FireHH/github_img_repository/redislfu.png",alt:""}})]),v._v(" "),e("p",[v._v("##6如何保证Redis的高并发和高可用\n主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FireHH/github_img_repository/redis%E9%AB%98%E5%8F%AF%E7%94%A8.png",alt:""}})]),v._v(" "),e("p",[v._v("##7 如何使用Redis实现延迟队列？如何使用Redis实现分布式锁？\n###业务场景：")]),v._v(" "),e("ul",[e("li",[v._v("订单一直处于未支付状态，如何及时关闭订单")]),v._v(" "),e("li",[v._v("如何定期检查退款状态，订单是否已经退款成功")])]),v._v(" "),e("p",[v._v("###Redis实现延迟队列：\n使用zset，list实现")]),v._v(" "),e("p",[v._v("###分布式锁\n加锁 set key value\nevl 解锁\ntimout")]),v._v(" "),e("p",[v._v("##8 什么是缓存雪崩，缓存穿透，缓存击穿，如何解决？\n###缓存穿透\n高并发下查询key不存在数据，导致直接查数据库")]),v._v(" "),e("ul",[e("li",[v._v("针对查询结果为空的也进行缓存，造成太多空值，占用空间")]),v._v(" "),e("li",[v._v("布隆过滤器，先去布隆过滤器查询key是否存在，不存在直接返回")])]),v._v(" "),e("p",[v._v("###缓存击穿：设置了过期时间的key，某个时间点过期，大量线程访问该数据")]),v._v(" "),e("ul",[e("li",[v._v("使用分布式锁控制访问线程")]),v._v(" "),e("li",[v._v("不设置超时时间，造成写一致性问题，可使用延迟双删")])]),v._v(" "),e("p",[v._v("###缓存雪崩：重启或大量的key失效")]),v._v(" "),e("ul",[e("li",[v._v("key的失效期分散开，不同的key设置不同的有效期")]),v._v(" "),e("li",[v._v("二级缓存，本地和redis")]),v._v(" "),e("li",[v._v("高可用，允许脏读，失效仍能查到数据但不是最新的")])]),v._v(" "),e("p",[v._v("##9什么是大key，热key，会造成什么问题？\n###大key：存储的值非常大\n"),e("strong",[v._v("问题：")]),v._v("\n占用很多内存，主动删除或过期删除时阻塞时间过长\n"),e("strong",[v._v("优化：")])]),v._v(" "),e("ul",[e("li",[v._v("String减少长度，List，Set减少成员数量")]),v._v(" "),e("li",[v._v("针对String，大key存储于其他数据库，Mondb或者缓存到CDN")]),v._v(" "),e("li",[v._v("hash，set，对元素进行拆分存储")]),v._v(" "),e("li",[v._v("删除不使用delete（阻塞），使用lazydelte(非阻塞)")])]),v._v(" "),e("p",[v._v("###热key：热点数据\n"),e("strong",[v._v("问题：")]),v._v(" 缓存击穿\n"),e("strong",[v._v("优化：")])]),v._v(" "),e("ul",[e("li",[v._v("热点数据直接加载到本地缓存，不要求强一致性")]),v._v(" "),e("li",[v._v("Redis主节点备份热key数据")]),v._v(" "),e("li",[v._v("对热Key限流熔断，每秒最多请求缓存集群不超过400次")])]),v._v(" "),e("h2",{attrs:{id:"_10-缓存和数据库中的数据不一致造成什么问题-如何解决-数据并发竞争-会造成什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-缓存和数据库中的数据不一致造成什么问题-如何解决-数据并发竞争-会造成什么问题"}},[v._v("#")]),v._v(" 10 缓存和数据库中的数据不一致造成什么问题，如何解决？数据并发竞争，会造成什么问题？")]),v._v(" "),e("p",[e("strong",[v._v("最终一致性：")]),v._v("\n延时双删，更新数据库时删除缓存，读取时在设置缓存，2s后在删除一次。")]),v._v(" "),e("p",[e("strong",[v._v("数据并发竞争：")]),v._v(" 分布式锁+时间戳")]),v._v(" "),e("h2",{attrs:{id:"_11单线程的redis为什么这么快"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11单线程的redis为什么这么快"}},[v._v("#")]),v._v(" 11单线程的Redis为什么这么快？")]),v._v(" "),e("p",[v._v("内存，集群，最大内存+淘汰策略，无锁，无线程调度切换，多路复用")])])}),[],!1,null,null,null);_.default=t.exports}}]);